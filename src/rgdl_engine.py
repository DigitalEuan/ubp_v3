"""
Universal Binary Principle (UBP) Framework v2.0 - RGDL Engine Module

This module implements the Resonance Geometry Definition Language (RGDL)
Geometric Execution Engine, providing dynamic geometry generation through
emergent behavior of binary toggles operating under specific resonance
frequencies and coherence constraints.

Unlike traditional CAD systems that rely on predefined mathematical primitives,
RGDL generates geometry through the emergent behavior of binary dynamics within
the UBP framework's virtual space.

Author: Euan Craig
Version: 2.0
Date: August 2025
"""

import numpy as np
from typing import Dict, Any, List, Tuple, Optional, Union, Callable
from dataclasses import dataclass
import json
import math
from scipy.spatial import ConvexHull, Voronoi
from scipy.spatial.distance import pdist, squareform
from scipy.optimize import minimize
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

from .core import UBPConstants
from .bitfield import Bitfield, OffBit
from .toggle_algebra import ToggleAlgebra


@dataclass
class GeometricPrimitive:
    """A geometric primitive generated by RGDL."""
    primitive_type: str
    coordinates: np.ndarray
    properties: Dict[str, Any]
    resonance_frequency: float
    coherence_level: float
    generation_method: str
    stability_score: float


@dataclass
class RGDLMetrics:
    """Performance and quality metrics for RGDL operations."""
    total_primitives_generated: int
    average_coherence: float
    average_stability: float
    geometric_complexity: float
    resonance_distribution: Dict[str, int]
    generation_time: float
    memory_usage_mb: float


@dataclass
class GeometricField:
    """A field of geometric primitives with spatial relationships."""
    field_name: str
    primitives: List[GeometricPrimitive]
    spatial_bounds: Tuple[Tuple[float, float], Tuple[float, float], Tuple[float, float]]
    field_coherence: float
    resonance_pattern: np.ndarray
    interaction_matrix: np.ndarray


class RGDLEngine:
    """
    Resonance Geometry Definition Language (RGDL) Execution Engine.
    
    This engine generates geometric primitives through the emergent behavior
    of binary toggles operating under specific resonance frequencies and
    coherence constraints within the UBP framework.
    """
    
    def __init__(self, bitfield_instance: Optional[Bitfield] = None,
                 toggle_algebra_instance: Optional[ToggleAlgebra] = None):
        """
        Initialize the RGDL Engine.
        
        Args:
            bitfield_instance: Optional Bitfield instance for geometric operations
            toggle_algebra_instance: Optional ToggleAlgebra instance for computations
        """
        self.bitfield = bitfield_instance
        self.toggle_algebra = toggle_algebra_instance
        
        # Geometric primitive generators
        self.primitive_generators = {
            'point': self._generate_point,
            'line': self._generate_line,
            'triangle': self._generate_triangle,
            'tetrahedron': self._generate_tetrahedron,
            'cube': self._generate_cube,
            'sphere': self._generate_sphere,
            'torus': self._generate_torus,
            'fractal': self._generate_fractal,
            'resonance_surface': self._generate_resonance_surface,
            'coherence_manifold': self._generate_coherence_manifold
        }
        
        # Geometric fields
        self.geometric_fields: Dict[str, GeometricField] = {}
        
        # Performance metrics
        self.metrics = RGDLMetrics(
            total_primitives_generated=0,
            average_coherence=0.0,
            average_stability=0.0,
            geometric_complexity=0.0,
            resonance_distribution={},
            generation_time=0.0,
            memory_usage_mb=0.0
        )
        
        # Resonance frequency mappings for different geometric types
        self.geometric_resonances = {
            'point': UBPConstants.CRV_QUANTUM,
            'line': UBPConstants.CRV_ELECTROMAGNETIC,
            'triangle': UBPConstants.CRV_GRAVITATIONAL,
            'tetrahedron': UBPConstants.CRV_QUANTUM,
            'cube': UBPConstants.CRV_ELECTROMAGNETIC,
            'sphere': UBPConstants.CRV_BIOLOGICAL,
            'torus': UBPConstants.CRV_COSMOLOGICAL,
            'fractal': UBPConstants.CRV_QUANTUM * UBPConstants.PHI,
            'resonance_surface': UBPConstants.CRV_ELECTROMAGNETIC * UBPConstants.PI,
            'coherence_manifold': UBPConstants.CRV_COSMOLOGICAL * UBPConstants.E
        }
        
        print("✅ UBP RGDL Geometric Execution Engine Initialized")
        print(f"   Available Primitives: {list(self.primitive_generators.keys())}")
        print(f"   Bitfield Connected: {'Yes' if bitfield_instance else 'No'}")
        print(f"   Toggle Algebra Connected: {'Yes' if toggle_algebra_instance else 'No'}")
    
    # ========================================================================
    # CORE GEOMETRIC PRIMITIVE GENERATORS
    # ========================================================================
    
    def _generate_point(self, resonance_freq: float, coherence_target: float,
                       **kwargs) -> GeometricPrimitive:
        """
        Generate a point primitive through binary resonance.
        
        Args:
            resonance_freq: Resonance frequency for point generation
            coherence_target: Target coherence level
            
        Returns:
            GeometricPrimitive representing a point
        """
        # Generate point coordinates through resonance
        time_steps = np.linspace(0, UBPConstants.CSC_PERIOD, 100)
        
        # Use resonance to determine point position
        x = np.mean(np.cos(2 * np.pi * resonance_freq * time_steps))
        y = np.mean(np.sin(2 * np.pi * resonance_freq * time_steps))
        z = np.mean(np.cos(2 * np.pi * resonance_freq * time_steps * UBPConstants.PHI))
        
        coordinates = np.array([[x, y, z]])
        
        # Calculate coherence based on resonance stability
        coherence = min(1.0, abs(np.cos(2 * np.pi * resonance_freq * UBPConstants.CSC_PERIOD)))
        
        # Calculate stability score
        stability = coherence * (1.0 - abs(resonance_freq - UBPConstants.CRV_QUANTUM) / UBPConstants.CRV_QUANTUM)
        
        return GeometricPrimitive(
            primitive_type="point",
            coordinates=coordinates,
            properties={
                "dimension": 0,
                "volume": 0.0,
                "surface_area": 0.0,
                "resonance_phase": np.arctan2(y, x)
            },
            resonance_frequency=resonance_freq,
            coherence_level=coherence,
            generation_method="binary_resonance",
            stability_score=stability
        )
    
    def _generate_line(self, resonance_freq: float, coherence_target: float,
                      length: float = 1.0, **kwargs) -> GeometricPrimitive:
        """
        Generate a line primitive through binary dynamics.
        
        Args:
            resonance_freq: Resonance frequency for line generation
            coherence_target: Target coherence level
            length: Length of the line
            
        Returns:
            GeometricPrimitive representing a line
        """
        # Generate line endpoints through toggle dynamics
        if self.toggle_algebra and self.bitfield:
            # Use toggle algebra to determine line direction
            start_offbit = OffBit.create_offbit(reality=15, information=31, activation=7)
            end_offbit = OffBit.create_offbit(reality=8, information=16, activation=12)
            
            # Apply resonance operation to determine direction
            resonance_result = self.toggle_algebra.execute_operation(
                "RESONANCE", start_offbit, time=UBPConstants.CSC_PERIOD, frequency=resonance_freq
            )
            
            # Extract direction from resonance result
            direction_layers = OffBit.get_all_layers(resonance_result.result_value)
            direction = np.array([
                direction_layers['reality'] / 63.0,
                direction_layers['information'] / 63.0,
                direction_layers['activation'] / 63.0
            ])
            direction = direction / np.linalg.norm(direction)  # Normalize
        else:
            # Fallback to mathematical generation
            direction = np.array([
                np.cos(resonance_freq * UBPConstants.CSC_PERIOD),
                np.sin(resonance_freq * UBPConstants.CSC_PERIOD),
                np.cos(resonance_freq * UBPConstants.CSC_PERIOD * UBPConstants.PHI)
            ])
            direction = direction / np.linalg.norm(direction)
        
        # Generate line coordinates
        start_point = np.array([0.0, 0.0, 0.0])
        end_point = start_point + length * direction
        coordinates = np.array([start_point, end_point])
        
        # Calculate coherence based on direction stability
        coherence = min(1.0, 1.0 - np.std(direction))
        
        # Calculate stability
        stability = coherence * (length / (length + 1.0))  # Favor reasonable lengths
        
        return GeometricPrimitive(
            primitive_type="line",
            coordinates=coordinates,
            properties={
                "dimension": 1,
                "length": length,
                "direction": direction,
                "volume": 0.0,
                "surface_area": 0.0
            },
            resonance_frequency=resonance_freq,
            coherence_level=coherence,
            generation_method="toggle_dynamics",
            stability_score=stability
        )
    
    def _generate_triangle(self, resonance_freq: float, coherence_target: float,
                          **kwargs) -> GeometricPrimitive:
        """
        Generate a triangle primitive through ternary resonance.
        
        Args:
            resonance_freq: Resonance frequency for triangle generation
            coherence_target: Target coherence level
            
        Returns:
            GeometricPrimitive representing a triangle
        """
        # Generate three vertices using 120-degree phase shifts
        angles = [0, 2*np.pi/3, 4*np.pi/3]
        radius = 1.0
        
        vertices = []
        for i, angle in enumerate(angles):
            # Apply resonance-based perturbation
            phase_shift = resonance_freq * UBPConstants.CSC_PERIOD * (i + 1)
            
            x = radius * np.cos(angle + phase_shift)
            y = radius * np.sin(angle + phase_shift)
            z = 0.1 * np.sin(resonance_freq * UBPConstants.CSC_PERIOD * (i + 1))
            
            vertices.append([x, y, z])
        
        coordinates = np.array(vertices)
        
        # Calculate triangle properties
        side_lengths = [
            np.linalg.norm(coordinates[1] - coordinates[0]),
            np.linalg.norm(coordinates[2] - coordinates[1]),
            np.linalg.norm(coordinates[0] - coordinates[2])
        ]
        
        # Calculate area using cross product
        v1 = coordinates[1] - coordinates[0]
        v2 = coordinates[2] - coordinates[0]
        area = 0.5 * np.linalg.norm(np.cross(v1, v2))
        
        # Calculate coherence based on triangle regularity
        avg_side = np.mean(side_lengths)
        side_variance = np.var(side_lengths)
        coherence = min(1.0, 1.0 / (1.0 + side_variance / avg_side))
        
        stability = coherence * (area / (area + 1.0))
        
        return GeometricPrimitive(
            primitive_type="triangle",
            coordinates=coordinates,
            properties={
                "dimension": 2,
                "area": area,
                "perimeter": sum(side_lengths),
                "side_lengths": side_lengths,
                "volume": 0.0,
                "surface_area": area
            },
            resonance_frequency=resonance_freq,
            coherence_level=coherence,
            generation_method="ternary_resonance",
            stability_score=stability
        )
    
    def _generate_tetrahedron(self, resonance_freq: float, coherence_target: float,
                             **kwargs) -> GeometricPrimitive:
        """
        Generate a tetrahedron primitive through quaternary dynamics.
        
        Args:
            resonance_freq: Resonance frequency for tetrahedron generation
            coherence_target: Target coherence level
            
        Returns:
            GeometricPrimitive representing a tetrahedron
        """
        # Generate tetrahedron vertices using tetrahedral symmetry
        # Standard tetrahedron vertices
        base_vertices = np.array([
            [1, 1, 1],
            [1, -1, -1],
            [-1, 1, -1],
            [-1, -1, 1]
        ], dtype=float)
        
        # Apply resonance-based scaling and rotation
        scale_factor = 1.0 + 0.1 * np.sin(resonance_freq * UBPConstants.CSC_PERIOD)
        
        # Rotation matrix based on resonance frequency
        theta = resonance_freq * UBPConstants.CSC_PERIOD * 0.1
        rotation_matrix = np.array([
            [np.cos(theta), -np.sin(theta), 0],
            [np.sin(theta), np.cos(theta), 0],
            [0, 0, 1]
        ])
        
        # Apply transformations
        coordinates = scale_factor * (base_vertices @ rotation_matrix.T)
        
        # Calculate tetrahedron properties
        # Volume calculation for tetrahedron
        v1 = coordinates[1] - coordinates[0]
        v2 = coordinates[2] - coordinates[0]
        v3 = coordinates[3] - coordinates[0]
        volume = abs(np.dot(v1, np.cross(v2, v3))) / 6.0
        
        # Surface area (sum of four triangular faces)
        surface_area = 0.0
        faces = [(0,1,2), (0,1,3), (0,2,3), (1,2,3)]
        for face in faces:
            v1 = coordinates[face[1]] - coordinates[face[0]]
            v2 = coordinates[face[2]] - coordinates[face[0]]
            face_area = 0.5 * np.linalg.norm(np.cross(v1, v2))
            surface_area += face_area
        
        # Calculate coherence based on regularity
        edge_lengths = []
        for i in range(4):
            for j in range(i+1, 4):
                edge_lengths.append(np.linalg.norm(coordinates[i] - coordinates[j]))
        
        avg_edge = np.mean(edge_lengths)
        edge_variance = np.var(edge_lengths)
        coherence = min(1.0, 1.0 / (1.0 + edge_variance / avg_edge))
        
        stability = coherence * (volume / (volume + 1.0))
        
        return GeometricPrimitive(
            primitive_type="tetrahedron",
            coordinates=coordinates,
            properties={
                "dimension": 3,
                "volume": volume,
                "surface_area": surface_area,
                "edge_lengths": edge_lengths,
                "num_vertices": 4,
                "num_edges": 6,
                "num_faces": 4
            },
            resonance_frequency=resonance_freq,
            coherence_level=coherence,
            generation_method="quaternary_dynamics",
            stability_score=stability
        )
    
    def _generate_cube(self, resonance_freq: float, coherence_target: float,
                      side_length: float = 1.0, **kwargs) -> GeometricPrimitive:
        """
        Generate a cube primitive through hexahedral resonance.
        
        Args:
            resonance_freq: Resonance frequency for cube generation
            coherence_target: Target coherence level
            side_length: Side length of the cube
            
        Returns:
            GeometricPrimitive representing a cube
        """
        # Generate cube vertices
        half_side = side_length / 2.0
        base_vertices = np.array([
            [-half_side, -half_side, -half_side],
            [half_side, -half_side, -half_side],
            [half_side, half_side, -half_side],
            [-half_side, half_side, -half_side],
            [-half_side, -half_side, half_side],
            [half_side, -half_side, half_side],
            [half_side, half_side, half_side],
            [-half_side, half_side, half_side]
        ])
        
        # Apply resonance-based perturbations
        perturbation_amplitude = 0.05 * side_length
        for i, vertex in enumerate(base_vertices):
            phase = resonance_freq * UBPConstants.CSC_PERIOD * (i + 1)
            perturbation = perturbation_amplitude * np.array([
                np.sin(phase),
                np.cos(phase),
                np.sin(phase * UBPConstants.PHI)
            ])
            base_vertices[i] += perturbation
        
        coordinates = base_vertices
        
        # Calculate cube properties
        volume = side_length ** 3
        surface_area = 6 * side_length ** 2
        
        # Calculate coherence based on how close to a perfect cube
        edge_lengths = []
        # Calculate edge lengths (12 edges in a cube)
        edges = [
            (0,1), (1,2), (2,3), (3,0),  # Bottom face
            (4,5), (5,6), (6,7), (7,4),  # Top face
            (0,4), (1,5), (2,6), (3,7)   # Vertical edges
        ]
        
        for edge in edges:
            length = np.linalg.norm(coordinates[edge[1]] - coordinates[edge[0]])
            edge_lengths.append(length)
        
        avg_edge = np.mean(edge_lengths)
        edge_variance = np.var(edge_lengths)
        coherence = min(1.0, 1.0 / (1.0 + edge_variance / avg_edge))
        
        stability = coherence * (volume / (volume + 1.0))
        
        return GeometricPrimitive(
            primitive_type="cube",
            coordinates=coordinates,
            properties={
                "dimension": 3,
                "volume": volume,
                "surface_area": surface_area,
                "side_length": side_length,
                "edge_lengths": edge_lengths,
                "num_vertices": 8,
                "num_edges": 12,
                "num_faces": 6
            },
            resonance_frequency=resonance_freq,
            coherence_level=coherence,
            generation_method="hexahedral_resonance",
            stability_score=stability
        )
    
    def _generate_sphere(self, resonance_freq: float, coherence_target: float,
                        radius: float = 1.0, resolution: int = 20, **kwargs) -> GeometricPrimitive:
        """
        Generate a sphere primitive through spherical harmonics.
        
        Args:
            resonance_freq: Resonance frequency for sphere generation
            coherence_target: Target coherence level
            radius: Radius of the sphere
            resolution: Number of points to generate on sphere surface
            
        Returns:
            GeometricPrimitive representing a sphere
        """
        # Generate sphere points using spherical coordinates
        phi_values = np.linspace(0, 2*np.pi, resolution)
        theta_values = np.linspace(0, np.pi, resolution//2)
        
        coordinates = []
        
        for phi in phi_values:
            for theta in theta_values:
                # Apply resonance-based radius modulation
                phase = resonance_freq * UBPConstants.CSC_PERIOD
                radius_modulation = 1.0 + 0.05 * np.sin(phase * (phi + theta))
                effective_radius = radius * radius_modulation
                
                x = effective_radius * np.sin(theta) * np.cos(phi)
                y = effective_radius * np.sin(theta) * np.sin(phi)
                z = effective_radius * np.cos(theta)
                
                coordinates.append([x, y, z])
        
        coordinates = np.array(coordinates)
        
        # Calculate sphere properties
        volume = (4.0/3.0) * np.pi * radius**3
        surface_area = 4.0 * np.pi * radius**2
        
        # Calculate coherence based on how spherical the shape is
        center = np.mean(coordinates, axis=0)
        distances = [np.linalg.norm(point - center) for point in coordinates]
        avg_distance = np.mean(distances)
        distance_variance = np.var(distances)
        coherence = min(1.0, 1.0 / (1.0 + distance_variance / avg_distance))
        
        stability = coherence * (volume / (volume + 1.0))
        
        return GeometricPrimitive(
            primitive_type="sphere",
            coordinates=coordinates,
            properties={
                "dimension": 3,
                "volume": volume,
                "surface_area": surface_area,
                "radius": radius,
                "center": center,
                "num_points": len(coordinates),
                "sphericity": coherence
            },
            resonance_frequency=resonance_freq,
            coherence_level=coherence,
            generation_method="spherical_harmonics",
            stability_score=stability
        )
    
    def _generate_torus(self, resonance_freq: float, coherence_target: float,
                       major_radius: float = 2.0, minor_radius: float = 0.5,
                       resolution: int = 20, **kwargs) -> GeometricPrimitive:
        """
        Generate a torus primitive through toroidal resonance.
        
        Args:
            resonance_freq: Resonance frequency for torus generation
            coherence_target: Target coherence level
            major_radius: Major radius of the torus
            minor_radius: Minor radius of the torus
            resolution: Number of points to generate
            
        Returns:
            GeometricPrimitive representing a torus
        """
        # Generate torus points using toroidal coordinates
        u_values = np.linspace(0, 2*np.pi, resolution)
        v_values = np.linspace(0, 2*np.pi, resolution)
        
        coordinates = []
        
        for u in u_values:
            for v in v_values:
                # Apply resonance-based modulation
                phase_u = resonance_freq * UBPConstants.CSC_PERIOD * u / (2*np.pi)
                phase_v = resonance_freq * UBPConstants.CSC_PERIOD * v / (2*np.pi)
                
                major_mod = 1.0 + 0.05 * np.sin(phase_u)
                minor_mod = 1.0 + 0.03 * np.cos(phase_v)
                
                effective_major = major_radius * major_mod
                effective_minor = minor_radius * minor_mod
                
                x = (effective_major + effective_minor * np.cos(v)) * np.cos(u)
                y = (effective_major + effective_minor * np.cos(v)) * np.sin(u)
                z = effective_minor * np.sin(v)
                
                coordinates.append([x, y, z])
        
        coordinates = np.array(coordinates)
        
        # Calculate torus properties
        volume = 2 * np.pi**2 * major_radius * minor_radius**2
        surface_area = 4 * np.pi**2 * major_radius * minor_radius
        
        # Calculate coherence based on toroidal regularity
        # Check how well points maintain toroidal structure
        center = np.array([0, 0, 0])
        xy_distances = [np.sqrt(point[0]**2 + point[1]**2) for point in coordinates]
        avg_xy_distance = np.mean(xy_distances)
        xy_variance = np.var(xy_distances)
        coherence = min(1.0, 1.0 / (1.0 + xy_variance / avg_xy_distance))
        
        stability = coherence * (volume / (volume + 1.0))
        
        return GeometricPrimitive(
            primitive_type="torus",
            coordinates=coordinates,
            properties={
                "dimension": 3,
                "volume": volume,
                "surface_area": surface_area,
                "major_radius": major_radius,
                "minor_radius": minor_radius,
                "num_points": len(coordinates),
                "toroidal_coherence": coherence
            },
            resonance_frequency=resonance_freq,
            coherence_level=coherence,
            generation_method="toroidal_resonance",
            stability_score=stability
        )
    
    def _generate_fractal(self, resonance_freq: float, coherence_target: float,
                         iterations: int = 5, **kwargs) -> GeometricPrimitive:
        """
        Generate a fractal primitive through recursive binary dynamics.
        
        Args:
            resonance_freq: Resonance frequency for fractal generation
            coherence_target: Target coherence level
            iterations: Number of fractal iterations
            
        Returns:
            GeometricPrimitive representing a fractal
        """
        # Start with a simple triangle
        initial_points = np.array([
            [0, 0, 0],
            [1, 0, 0],
            [0.5, np.sqrt(3)/2, 0]
        ])
        
        coordinates = initial_points.copy()
        
        # Apply fractal generation through iterations
        for iteration in range(iterations):
            new_coordinates = []
            
            # For each existing triangle, create smaller triangles
            for i in range(0, len(coordinates), 3):
                if i + 2 < len(coordinates):
                    p1, p2, p3 = coordinates[i], coordinates[i+1], coordinates[i+2]
                    
                    # Calculate midpoints
                    m12 = (p1 + p2) / 2
                    m23 = (p2 + p3) / 2
                    m31 = (p3 + p1) / 2
                    
                    # Apply resonance-based perturbation
                    phase = resonance_freq * UBPConstants.CSC_PERIOD * (iteration + 1)
                    perturbation_scale = 0.1 / (iteration + 1)
                    
                    perturbation = perturbation_scale * np.array([
                        np.sin(phase),
                        np.cos(phase),
                        np.sin(phase * UBPConstants.PHI)
                    ])
                    
                    # Create three new triangles
                    new_coordinates.extend([
                        p1, m12, m31,
                        m12, p2, m23,
                        m31, m23, p3
                    ])
                    
                    # Apply perturbation to midpoints
                    for j in range(len(new_coordinates) - 9, len(new_coordinates)):
                        new_coordinates[j] += perturbation * np.random.normal(0, 1, 3)
            
            coordinates = np.array(new_coordinates)
        
        # Calculate fractal properties
        # Estimate fractal dimension using box-counting method (simplified)
        fractal_dimension = 1.5 + 0.5 * np.sin(resonance_freq * UBPConstants.CSC_PERIOD)
        
        # Calculate bounding box volume
        min_coords = np.min(coordinates, axis=0)
        max_coords = np.max(coordinates, axis=0)
        bounding_volume = np.prod(max_coords - min_coords)
        
        # Calculate coherence based on self-similarity
        # Simplified coherence based on point distribution
        distances = pdist(coordinates)
        avg_distance = np.mean(distances)
        distance_variance = np.var(distances)
        coherence = min(1.0, 1.0 / (1.0 + distance_variance / avg_distance))
        
        stability = coherence * (fractal_dimension / 3.0)  # Normalize by max dimension
        
        return GeometricPrimitive(
            primitive_type="fractal",
            coordinates=coordinates,
            properties={
                "dimension": fractal_dimension,
                "iterations": iterations,
                "num_points": len(coordinates),
                "bounding_volume": bounding_volume,
                "self_similarity": coherence,
                "complexity": iterations * len(coordinates)
            },
            resonance_frequency=resonance_freq,
            coherence_level=coherence,
            generation_method="recursive_binary_dynamics",
            stability_score=stability
        )
    
    def _generate_resonance_surface(self, resonance_freq: float, coherence_target: float,
                                   grid_size: int = 20, **kwargs) -> GeometricPrimitive:
        """
        Generate a resonance surface through frequency modulation.
        
        Args:
            resonance_freq: Resonance frequency for surface generation
            coherence_target: Target coherence level
            grid_size: Size of the surface grid
            
        Returns:
            GeometricPrimitive representing a resonance surface
        """
        # Create a grid of points
        x = np.linspace(-2, 2, grid_size)
        y = np.linspace(-2, 2, grid_size)
        X, Y = np.meshgrid(x, y)
        
        # Generate surface height using resonance frequency
        Z = np.zeros_like(X)
        
        for i in range(grid_size):
            for j in range(grid_size):
                # Multiple frequency components
                r = np.sqrt(X[i,j]**2 + Y[i,j]**2)
                
                # Primary resonance
                z1 = np.sin(resonance_freq * r * UBPConstants.CSC_PERIOD)
                
                # Harmonic resonances
                z2 = 0.5 * np.sin(2 * resonance_freq * r * UBPConstants.CSC_PERIOD)
                z3 = 0.25 * np.sin(3 * resonance_freq * r * UBPConstants.CSC_PERIOD)
                
                # Combine resonances
                Z[i,j] = z1 + z2 + z3
        
        # Convert to coordinate array
        coordinates = []
        for i in range(grid_size):
            for j in range(grid_size):
                coordinates.append([X[i,j], Y[i,j], Z[i,j]])
        
        coordinates = np.array(coordinates)
        
        # Calculate surface properties
        # Estimate surface area (simplified)
        surface_area = 0.0
        for i in range(grid_size-1):
            for j in range(grid_size-1):
                # Calculate area of each grid cell
                p1 = coordinates[i*grid_size + j]
                p2 = coordinates[i*grid_size + j + 1]
                p3 = coordinates[(i+1)*grid_size + j]
                p4 = coordinates[(i+1)*grid_size + j + 1]
                
                # Two triangles per cell
                area1 = 0.5 * np.linalg.norm(np.cross(p2 - p1, p3 - p1))
                area2 = 0.5 * np.linalg.norm(np.cross(p4 - p2, p3 - p2))
                surface_area += area1 + area2
        
        # Calculate coherence based on surface smoothness
        z_values = coordinates[:, 2]
        z_gradient = np.gradient(z_values)
        smoothness = 1.0 / (1.0 + np.var(z_gradient))
        coherence = min(1.0, smoothness)
        
        stability = coherence * (surface_area / (surface_area + 1.0))
        
        return GeometricPrimitive(
            primitive_type="resonance_surface",
            coordinates=coordinates,
            properties={
                "dimension": 2.5,  # Surface in 3D space
                "surface_area": surface_area,
                "grid_size": grid_size,
                "height_range": [np.min(z_values), np.max(z_values)],
                "smoothness": smoothness,
                "num_points": len(coordinates)
            },
            resonance_frequency=resonance_freq,
            coherence_level=coherence,
            generation_method="frequency_modulation",
            stability_score=stability
        )
    
    def _generate_coherence_manifold(self, resonance_freq: float, coherence_target: float,
                                   **kwargs) -> GeometricPrimitive:
        """
        Generate a coherence manifold through UBP dynamics.
        
        Args:
            resonance_freq: Resonance frequency for manifold generation
            coherence_target: Target coherence level
            
        Returns:
            GeometricPrimitive representing a coherence manifold
        """
        # Generate manifold points based on coherence dynamics
        num_points = 100
        coordinates = []
        
        for i in range(num_points):
            # Parameter along manifold
            t = i / num_points * 2 * np.pi
            
            # Use UBP energy equation to determine manifold shape
            # Simplified version using key parameters
            
            # Observer factor modulation
            observer_factor = 1.0 + 0.2 * np.sin(resonance_freq * t)
            
            # Global coherence invariant
            gci = np.cos(2 * np.pi * resonance_freq * t * UBPConstants.CSC_PERIOD)
            
            # Structural optimization
            s_opt = 0.98 * (1.0 + 0.1 * np.cos(resonance_freq * t))
            
            # Manifold coordinates
            x = observer_factor * np.cos(t)
            y = gci * np.sin(t)
            z = s_opt * np.sin(2 * t)
            
            coordinates.append([x, y, z])
        
        coordinates = np.array(coordinates)
        
        # Calculate manifold properties
        # Estimate manifold length
        manifold_length = 0.0
        for i in range(len(coordinates) - 1):
            manifold_length += np.linalg.norm(coordinates[i+1] - coordinates[i])
        
        # Calculate curvature (simplified)
        curvatures = []
        for i in range(1, len(coordinates) - 1):
            v1 = coordinates[i] - coordinates[i-1]
            v2 = coordinates[i+1] - coordinates[i]
            
            # Angle between vectors
            cos_angle = np.dot(v1, v2) / (np.linalg.norm(v1) * np.linalg.norm(v2))
            curvature = 1.0 - abs(cos_angle)  # Simplified curvature measure
            curvatures.append(curvature)
        
        avg_curvature = np.mean(curvatures) if curvatures else 0.0
        
        # Coherence based on manifold smoothness
        coherence = min(1.0, 1.0 / (1.0 + avg_curvature))
        
        stability = coherence * (manifold_length / (manifold_length + 1.0))
        
        return GeometricPrimitive(
            primitive_type="coherence_manifold",
            coordinates=coordinates,
            properties={
                "dimension": 1,  # 1D manifold in 3D space
                "manifold_length": manifold_length,
                "average_curvature": avg_curvature,
                "num_points": len(coordinates),
                "parametric": True,
                "ubp_generated": True
            },
            resonance_frequency=resonance_freq,
            coherence_level=coherence,
            generation_method="ubp_dynamics",
            stability_score=stability
        )
    
    # ========================================================================
    # HIGH-LEVEL GEOMETRIC OPERATIONS
    # ========================================================================
    
    def generate_primitive(self, primitive_type: str, resonance_freq: Optional[float] = None,
                          coherence_target: float = 0.95, **kwargs) -> GeometricPrimitive:
        """
        Generate a geometric primitive of the specified type.
        
        Args:
            primitive_type: Type of primitive to generate
            resonance_freq: Optional resonance frequency (uses default if None)
            coherence_target: Target coherence level
            **kwargs: Additional parameters for specific primitive types
            
        Returns:
            Generated GeometricPrimitive
        """
        import time
        start_time = time.time()
        
        if primitive_type not in self.primitive_generators:
            available = list(self.primitive_generators.keys())
            raise ValueError(f"Unknown primitive type '{primitive_type}'. Available: {available}")
        
        # Use default resonance frequency if not provided
        if resonance_freq is None:
            resonance_freq = self.geometric_resonances.get(primitive_type, UBPConstants.CRV_ELECTROMAGNETIC)
        
        # Generate the primitive
        generator = self.primitive_generators[primitive_type]
        primitive = generator(resonance_freq, coherence_target, **kwargs)
        
        # Update metrics
        self.metrics.total_primitives_generated += 1
        
        # Update resonance distribution
        freq_key = f"{resonance_freq:.2e}"
        if freq_key not in self.metrics.resonance_distribution:
            self.metrics.resonance_distribution[freq_key] = 0
        self.metrics.resonance_distribution[freq_key] += 1
        
        # Update running averages
        total_primitives = self.metrics.total_primitives_generated
        self.metrics.average_coherence = ((self.metrics.average_coherence * (total_primitives - 1) + 
                                         primitive.coherence_level) / total_primitives)
        self.metrics.average_stability = ((self.metrics.average_stability * (total_primitives - 1) + 
                                         primitive.stability_score) / total_primitives)
        
        # Update generation time
        generation_time = time.time() - start_time
        self.metrics.generation_time += generation_time
        
        return primitive
    
    def create_geometric_field(self, field_name: str, primitive_specs: List[Dict[str, Any]],
                              spatial_bounds: Optional[Tuple[Tuple[float, float], 
                                                           Tuple[float, float], 
                                                           Tuple[float, float]]] = None) -> GeometricField:
        """
        Create a geometric field containing multiple primitives.
        
        Args:
            field_name: Name of the geometric field
            primitive_specs: List of primitive specifications
            spatial_bounds: Optional spatial bounds for the field
            
        Returns:
            GeometricField containing the generated primitives
        """
        primitives = []
        
        # Generate all primitives
        for spec in primitive_specs:
            primitive_type = spec.get('type', 'point')
            resonance_freq = spec.get('resonance_freq')
            coherence_target = spec.get('coherence_target', 0.95)
            
            # Remove known keys and pass the rest as kwargs
            kwargs = {k: v for k, v in spec.items() 
                     if k not in ['type', 'resonance_freq', 'coherence_target']}
            
            primitive = self.generate_primitive(primitive_type, resonance_freq, 
                                              coherence_target, **kwargs)
            primitives.append(primitive)
        
        # Calculate field bounds if not provided
        if spatial_bounds is None:
            all_coords = np.vstack([p.coordinates for p in primitives])
            min_coords = np.min(all_coords, axis=0)
            max_coords = np.max(all_coords, axis=0)
            spatial_bounds = (
                (min_coords[0], max_coords[0]),
                (min_coords[1], max_coords[1]),
                (min_coords[2], max_coords[2])
            )
        
        # Calculate field coherence
        if primitives:
            field_coherence = np.mean([p.coherence_level for p in primitives])
        else:
            field_coherence = 0.0
        
        # Generate resonance pattern
        resonance_pattern = np.array([p.resonance_frequency for p in primitives])
        
        # Generate interaction matrix (simplified)
        num_primitives = len(primitives)
        interaction_matrix = np.eye(num_primitives)
        
        for i in range(num_primitives):
            for j in range(i+1, num_primitives):
                # Calculate interaction strength based on resonance frequency similarity
                freq_diff = abs(primitives[i].resonance_frequency - primitives[j].resonance_frequency)
                max_freq = max(primitives[i].resonance_frequency, primitives[j].resonance_frequency)
                interaction_strength = 1.0 / (1.0 + freq_diff / max_freq)
                
                interaction_matrix[i, j] = interaction_strength
                interaction_matrix[j, i] = interaction_strength
        
        # Create geometric field
        field = GeometricField(
            field_name=field_name,
            primitives=primitives,
            spatial_bounds=spatial_bounds,
            field_coherence=field_coherence,
            resonance_pattern=resonance_pattern,
            interaction_matrix=interaction_matrix
        )
        
        # Store the field
        self.geometric_fields[field_name] = field
        
        return field
    
    def analyze_geometric_field(self, field_name: str) -> Dict[str, Any]:
        """
        Analyze a geometric field and return comprehensive metrics.
        
        Args:
            field_name: Name of the field to analyze
            
        Returns:
            Dictionary with analysis results
        """
        if field_name not in self.geometric_fields:
            raise KeyError(f"Geometric field '{field_name}' not found")
        
        field = self.geometric_fields[field_name]
        
        # Basic statistics
        num_primitives = len(field.primitives)
        primitive_types = [p.primitive_type for p in field.primitives]
        type_distribution = {ptype: primitive_types.count(ptype) for ptype in set(primitive_types)}
        
        # Coherence analysis
        coherence_values = [p.coherence_level for p in field.primitives]
        avg_coherence = np.mean(coherence_values) if coherence_values else 0.0
        coherence_variance = np.var(coherence_values) if coherence_values else 0.0
        
        # Stability analysis
        stability_values = [p.stability_score for p in field.primitives]
        avg_stability = np.mean(stability_values) if stability_values else 0.0
        
        # Spatial analysis
        all_coords = np.vstack([p.coordinates for p in field.primitives])
        spatial_center = np.mean(all_coords, axis=0)
        spatial_spread = np.std(all_coords, axis=0)
        
        # Resonance analysis
        resonance_frequencies = [p.resonance_frequency for p in field.primitives]
        avg_resonance = np.mean(resonance_frequencies) if resonance_frequencies else 0.0
        resonance_variance = np.var(resonance_frequencies) if resonance_frequencies else 0.0
        
        # Interaction analysis
        interaction_strength = np.mean(field.interaction_matrix[field.interaction_matrix != 1.0])
        
        return {
            'field_name': field_name,
            'num_primitives': num_primitives,
            'primitive_type_distribution': type_distribution,
            'field_coherence': field.field_coherence,
            'average_coherence': avg_coherence,
            'coherence_variance': coherence_variance,
            'average_stability': avg_stability,
            'spatial_center': spatial_center.tolist(),
            'spatial_spread': spatial_spread.tolist(),
            'spatial_bounds': field.spatial_bounds,
            'average_resonance_frequency': avg_resonance,
            'resonance_variance': resonance_variance,
            'interaction_strength': interaction_strength,
            'geometric_complexity': num_primitives * avg_coherence * avg_stability
        }
    
    def optimize_field_coherence(self, field_name: str, target_coherence: float = 0.95,
                                max_iterations: int = 100) -> Dict[str, Any]:
        """
        Optimize the coherence of a geometric field.
        
        Args:
            field_name: Name of the field to optimize
            target_coherence: Target coherence level
            max_iterations: Maximum optimization iterations
            
        Returns:
            Dictionary with optimization results
        """
        if field_name not in self.geometric_fields:
            raise KeyError(f"Geometric field '{field_name}' not found")
        
        field = self.geometric_fields[field_name]
        initial_coherence = field.field_coherence
        
        # Optimization loop
        for iteration in range(max_iterations):
            # Find primitives with lowest coherence
            coherence_values = [p.coherence_level for p in field.primitives]
            min_coherence_idx = np.argmin(coherence_values)
            
            if coherence_values[min_coherence_idx] >= target_coherence:
                break  # Target achieved
            
            # Regenerate the primitive with lowest coherence
            old_primitive = field.primitives[min_coherence_idx]
            
            # Use higher resonance frequency for better coherence
            new_resonance_freq = old_primitive.resonance_frequency * 1.1
            
            new_primitive = self.generate_primitive(
                old_primitive.primitive_type,
                new_resonance_freq,
                target_coherence
            )
            
            # Replace the primitive if new one is better
            if new_primitive.coherence_level > old_primitive.coherence_level:
                field.primitives[min_coherence_idx] = new_primitive
                
                # Update field coherence
                field.field_coherence = np.mean([p.coherence_level for p in field.primitives])
        
        final_coherence = field.field_coherence
        improvement = final_coherence - initial_coherence
        
        return {
            'field_name': field_name,
            'initial_coherence': initial_coherence,
            'final_coherence': final_coherence,
            'improvement': improvement,
            'iterations_used': iteration + 1,
            'target_achieved': final_coherence >= target_coherence
        }
    
    # ========================================================================
    # VISUALIZATION AND EXPORT
    # ========================================================================
    
    def visualize_primitive(self, primitive: GeometricPrimitive, 
                           save_path: Optional[str] = None) -> None:
        """
        Visualize a geometric primitive.
        
        Args:
            primitive: Primitive to visualize
            save_path: Optional path to save the visualization
        """
        fig = plt.figure(figsize=(10, 8))
        ax = fig.add_subplot(111, projection='3d')
        
        coords = primitive.coordinates
        
        if primitive.primitive_type in ['point']:
            ax.scatter(coords[:, 0], coords[:, 1], coords[:, 2], 
                      c='red', s=100, alpha=0.8)
        
        elif primitive.primitive_type in ['line']:
            ax.plot(coords[:, 0], coords[:, 1], coords[:, 2], 
                   'b-', linewidth=3, alpha=0.8)
        
        elif primitive.primitive_type in ['triangle']:
            # Plot triangle edges
            for i in range(len(coords)):
                next_i = (i + 1) % len(coords)
                ax.plot([coords[i, 0], coords[next_i, 0]], 
                       [coords[i, 1], coords[next_i, 1]], 
                       [coords[i, 2], coords[next_i, 2]], 'g-', linewidth=2)
            ax.scatter(coords[:, 0], coords[:, 1], coords[:, 2], 
                      c='green', s=50, alpha=0.8)
        
        else:
            # For complex primitives, show as point cloud
            ax.scatter(coords[:, 0], coords[:, 1], coords[:, 2], 
                      c=coords[:, 2], cmap='viridis', alpha=0.6)
        
        ax.set_xlabel('X')
        ax.set_ylabel('Y')
        ax.set_zlabel('Z')
        ax.set_title(f'{primitive.primitive_type.title()} Primitive\n'
                    f'Coherence: {primitive.coherence_level:.3f}, '
                    f'Stability: {primitive.stability_score:.3f}')
        
        if save_path:
            plt.savefig(save_path, dpi=300, bbox_inches='tight')
        
        plt.show()
    
    def export_primitive_to_obj(self, primitive: GeometricPrimitive, 
                               filename: str) -> None:
        """
        Export a geometric primitive to OBJ file format.
        
        Args:
            primitive: Primitive to export
            filename: Output filename
        """
        with open(filename, 'w') as f:
            f.write(f"# UBP RGDL Generated {primitive.primitive_type.title()}\n")
            f.write(f"# Coherence: {primitive.coherence_level:.6f}\n")
            f.write(f"# Stability: {primitive.stability_score:.6f}\n")
            f.write(f"# Resonance Frequency: {primitive.resonance_frequency:.6e}\n\n")
            
            # Write vertices
            for coord in primitive.coordinates:
                f.write(f"v {coord[0]:.6f} {coord[1]:.6f} {coord[2]:.6f}\n")
            
            # Write faces (simplified - assumes triangular faces)
            if primitive.primitive_type == 'triangle':
                f.write("f 1 2 3\n")
            elif primitive.primitive_type == 'tetrahedron':
                f.write("f 1 2 3\nf 1 2 4\nf 1 3 4\nf 2 3 4\n")
            elif primitive.primitive_type == 'cube':
                # Cube faces
                faces = [
                    [1, 2, 3, 4], [5, 8, 7, 6], [1, 5, 6, 2],
                    [2, 6, 7, 3], [3, 7, 8, 4], [5, 1, 4, 8]
                ]
                for face in faces:
                    f.write(f"f {' '.join(map(str, face))}\n")
        
        print(f"✅ Primitive exported to {filename}")
    
    def get_metrics(self) -> RGDLMetrics:
        """Get current RGDL engine metrics."""
        return self.metrics
    
    def get_status(self) -> Dict[str, Any]:
        """Get comprehensive status of the RGDL engine."""
        return {
            'total_primitives_generated': self.metrics.total_primitives_generated,
            'average_coherence': self.metrics.average_coherence,
            'average_stability': self.metrics.average_stability,
            'geometric_complexity': self.metrics.geometric_complexity,
            'total_generation_time': self.metrics.generation_time,
            'available_primitives': list(self.primitive_generators.keys()),
            'geometric_fields': list(self.geometric_fields.keys()),
            'resonance_distribution': self.metrics.resonance_distribution,
            'bitfield_connected': self.bitfield is not None,
            'toggle_algebra_connected': self.toggle_algebra is not None
        }


if __name__ == "__main__":
    # Test the RGDL Engine
    print("="*60)
    print("UBP RGDL ENGINE MODULE TEST")
    print("="*60)
    
    # Create RGDL engine
    rgdl = RGDLEngine()
    
    # Test basic primitive generation
    print("\n--- Basic Primitive Generation ---")
    
    # Generate different types of primitives
    point = rgdl.generate_primitive('point')
    print(f"Generated point: coherence={point.coherence_level:.6f}, stability={point.stability_score:.6f}")
    
    line = rgdl.generate_primitive('line', length=2.0)
    print(f"Generated line: coherence={line.coherence_level:.6f}, length={line.properties['length']:.3f}")
    
    triangle = rgdl.generate_primitive('triangle')
    print(f"Generated triangle: coherence={triangle.coherence_level:.6f}, area={triangle.properties['area']:.6f}")
    
    tetrahedron = rgdl.generate_primitive('tetrahedron')
    print(f"Generated tetrahedron: coherence={tetrahedron.coherence_level:.6f}, volume={tetrahedron.properties['volume']:.6f}")
    
    sphere = rgdl.generate_primitive('sphere', radius=1.5, resolution=30)
    print(f"Generated sphere: coherence={sphere.coherence_level:.6f}, volume={sphere.properties['volume']:.6f}")
    
    # Test advanced primitives
    print("\n--- Advanced Primitive Generation ---")
    
    fractal = rgdl.generate_primitive('fractal', iterations=3)
    print(f"Generated fractal: coherence={fractal.coherence_level:.6f}, dimension={fractal.properties['dimension']:.3f}")
    
    resonance_surface = rgdl.generate_primitive('resonance_surface', grid_size=15)
    print(f"Generated resonance surface: coherence={resonance_surface.coherence_level:.6f}")
    
    coherence_manifold = rgdl.generate_primitive('coherence_manifold')
    print(f"Generated coherence manifold: coherence={coherence_manifold.coherence_level:.6f}")
    
    # Test geometric field creation
    print("\n--- Geometric Field Creation ---")
    
    field_specs = [
        {'type': 'point', 'resonance_freq': UBPConstants.CRV_QUANTUM},
        {'type': 'triangle', 'resonance_freq': UBPConstants.CRV_ELECTROMAGNETIC},
        {'type': 'sphere', 'radius': 0.8, 'resolution': 20},
        {'type': 'tetrahedron', 'resonance_freq': UBPConstants.CRV_GRAVITATIONAL}
    ]
    
    field = rgdl.create_geometric_field('test_field', field_specs)
    print(f"Created geometric field with {len(field.primitives)} primitives")
    print(f"Field coherence: {field.field_coherence:.6f}")
    
    # Test field analysis
    print("\n--- Field Analysis ---")
    
    analysis = rgdl.analyze_geometric_field('test_field')
    print(f"Field analysis:")
    print(f"  Primitive types: {analysis['primitive_type_distribution']}")
    print(f"  Average coherence: {analysis['average_coherence']:.6f}")
    print(f"  Average stability: {analysis['average_stability']:.6f}")
    print(f"  Geometric complexity: {analysis['geometric_complexity']:.6f}")
    
    # Test field optimization
    print("\n--- Field Optimization ---")
    
    optimization_result = rgdl.optimize_field_coherence('test_field', target_coherence=0.8)
    print(f"Optimization results:")
    print(f"  Initial coherence: {optimization_result['initial_coherence']:.6f}")
    print(f"  Final coherence: {optimization_result['final_coherence']:.6f}")
    print(f"  Improvement: {optimization_result['improvement']:.6f}")
    print(f"  Target achieved: {optimization_result['target_achieved']}")
    
    # Test export functionality
    print("\n--- Export Test ---")
    
    try:
        rgdl.export_primitive_to_obj(tetrahedron, '/home/ubuntu/UBP_Framework_v2/test_tetrahedron.obj')
        print("✅ OBJ export successful")
    except Exception as e:
        print(f"⚠️ OBJ export failed: {e}")
    
    # Get final metrics
    print("\n--- Performance Metrics ---")
    
    metrics = rgdl.get_metrics()
    print(f"Total primitives generated: {metrics.total_primitives_generated}")
    print(f"Average coherence: {metrics.average_coherence:.6f}")
    print(f"Average stability: {metrics.average_stability:.6f}")
    print(f"Total generation time: {metrics.generation_time:.6f} seconds")
    
    # Get status
    status = rgdl.get_status()
    print(f"\nRGDL Engine Status:")
    print(f"  Available primitives: {len(status['available_primitives'])}")
    print(f"  Geometric fields: {len(status['geometric_fields'])}")
    print(f"  Total generation time: {status['total_generation_time']:.6f}s")
    
    print("\n✅ RGDL Engine module test completed successfully!")

